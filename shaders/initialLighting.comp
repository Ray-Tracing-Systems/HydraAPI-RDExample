#version 440

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;
layout(push_constant) uniform Parameters {
  mat4 lighttm;
};

struct DirectLight {
  vec3 position;
  float innerRadius;
  vec3 direction;
  float outerRadius;
  vec3 color;
  float padding;
};

struct SpotLight {
  vec3 position;
  float innerCos;
  vec3 direction;
  float outerCos;
  vec3 color;
  float padding;
};

layout(binding = 0) uniform Lights {
  DirectLight directLights[1];
  SpotLight spotLights[1];
} lights;

layout (binding = 1) uniform DrawConsts {
  mat4 invViewProj;
  vec3 bmin;
  vec3 bmax;
  uvec3 gridSize;
  vec3 averageLighting;
};

const int MAX_VIRTUAL_PATCHES = 4;

layout(binding = 2) buffer layout1 { vec4 lightingBuffer[]; };
layout(binding = 3) buffer readonly layout2 { vec4 lightingWeightsBuffer[]; };
layout(binding = 4) buffer readonly layout3 { int voxelIdToIdx[]; };
layout(binding = 5) buffer readonly layout4 { vec4 colors[]; };
layout(binding = 6) uniform sampler2D shadowMap;

float saturate(float a) {
  return clamp(a, 0, 1);
}

vec3 ComputeLighting(vec3 worldPos, vec3 normal, DirectLight light) {
  vec3 pointToLight = light.position - worldPos;
  vec3 pointToLightDir = normalize(pointToLight);
  float lightDot = dot(-pointToLightDir, normalize(light.direction));
  if (lightDot <= 0) {
    return vec3(0);
  }

  vec4 lightPos = lighttm * vec4(worldPos, 1.0);
  lightPos /= lightPos.w;
  vec2 lightUv = lightPos.xy * 0.5 + 0.5;
  float shadow = 0.0;
  float shadowDepth = texture(shadowMap, lightUv).x;
  if (shadowDepth < lightPos.z - 1e-3) {
    return vec3(0);
  }

  vec3 tangentVec = -pointToLight - normalize(light.direction) * lightDot * length(pointToLight);
  float radius = length(tangentVec);
  float distMult = saturate((light.outerRadius - radius) / (light.outerRadius - light.innerRadius));
  return max(dot(pointToLightDir, normal), 0.0) * light.color * distMult;
}

vec3 ComputeLighting(vec3 worldPos, vec3 normal, SpotLight light) {
  if (length(light.direction) < 1e-5) {
    return vec3(0);
  }
  vec3 pointToLight = light.position - worldPos;
  vec3 pointToLightDir = normalize(pointToLight);
  float lightDot = dot(-pointToLightDir, normalize(light.direction));
  if (lightDot <= 0) {
    return vec3(0);
  }
  vec4 lightPos = lighttm * vec4(worldPos, 1.0);
  lightPos /= lightPos.w;
  vec2 lightUv = lightPos.xy * 0.5 + 0.5;
  float shadow = 0.0;
  ivec2 shadowSize = textureSize(shadowMap, 0);
  for (float x = -1.5; x <= 1.5; x += 1.0) {
    for (float y = -1.5; y <= 1.5; y += 1.0) {
      float shadowDepth = texture(shadowMap, lightUv + vec2(x, y) / shadowSize).x;
      shadow += shadowDepth < lightPos.z - 1e-5f ? 0.0 : 1.0 / 16.0;
    }
  }

  float distMult = saturate((light.innerCos - dot(normalize(light.direction), -normalize(pointToLight))) / (light.innerCos - light.outerCos));
  return max(dot(pointToLightDir, normal), 0.0) * light.color * distMult * shadow;
}

void main(){
  if (gridSize.x <= gl_GlobalInvocationID.x || gridSize.y <= gl_GlobalInvocationID.y || gridSize.z <= gl_GlobalInvocationID.z) {
    return;
  }

  vec3 bboxSize = bmax - bmin;
  vec3 voxelSize = bboxSize / gridSize;
  vec3 halfVoxelSize = voxelSize * 0.5;
  vec3 voxelId = vec3(gl_GlobalInvocationID);
  vec3 voxelCenter = voxelId * voxelSize + halfVoxelSize + bmin;

  uint flattenIndex = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gridSize.x + gl_GlobalInvocationID.z * gridSize.x * gridSize.y;
  for (int i = 0; i < MAX_VIRTUAL_PATCHES; ++i) {
    uint idx = flattenIndex * MAX_VIRTUAL_PATCHES + i;
    if (voxelIdToIdx[idx] == -1) {
        continue;
    }
    vec4 normal_valid = lightingWeightsBuffer[idx];
    vec3 lighting = lights.directLights[0].padding == 0 ? ComputeLighting(voxelCenter, normal_valid.xyz, lights.directLights[0]) : ComputeLighting(voxelCenter, normal_valid.xyz, lights.spotLights[0]);
    lightingBuffer[voxelIdToIdx[idx]].xyz = lighting * normal_valid.w * colors[voxelIdToIdx[idx]].xyz;
  }
}
